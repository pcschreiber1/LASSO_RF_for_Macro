if (length(beta) != p){
cat("Number of beta coefficient unequal to p")
}else{
#Mean of explanatory variables
mu = rep(0,p) #all covariates are standardized with mean zero
#Variance-Covariance Matrix
###Note: Matrix only depends on p and rho
toep = rho^(0:(p-1)) #creates geometric series starting at one
sigma = toeplitz(toep) #creates toeplitz matrix from geometric series: rho^(i-j)
X = mvrnorm(n, mu, sigma)
epsilon = rnorm(n, 0, var_error)
Y = X %*% beta + epsilon
#-------Creating data frame
df <- data.frame(Y, X)
return(df)
}
}
beta = c(1,1,1, rep(0, 97))
df <- simulate(n=10, p=100, rho=0.5, beta=beta, var_error = 1)
View(df)
View(results)
library(ggplot2)
n_sim = 10
colnames <- c("ID_sim", "SNR", "Method", "Retention", "Nonzero", "Prediction")
snr.vec = exp(seq(log(0.05), log(6), length(10)))
results = matrix(NaN, ncol=6, nrows=n_sim*3*length(snr.vec))
colnames(results) = colnames
View(results)
colnames <- c("ID_sim", "SNR", "Method", "Retention", "Nonzero", "Prediction")
snr.vec = exp(seq(log(0.05), log(6), length(10)))
results = matrix(NaN, ncol=6, nrows=(n_sim*3*length(snr.vec)))
colnames(results) = colnames
View(results)
results = matrix(NaN, ncol=6, nrows=(n_sim*3*length(snr.vec)))
colnames <- c("ID_sim", "SNR", "Method", "Retention", "Nonzero", "Prediction")
snr.vec = exp(seq(log(0.05), log(6), length(10)))
results = matrix(NaN, ncol=6, nrow=(n_sim*3*length(snr.vec)))
colnames(results) = colnames
View(results)
setwd("C:\Projects\Comp_Stat_Project")
sim1 <- read.csv("sim1.csv", header=TRUE)
View(sim1)
getwd()
setwd("C:/Projects/Comp_Stat_Project")
sim1 <- read.csv("sim1.csv", header=TRUE)
View(sim1)
#Find mean for each
mean(sim1$Retention[sim1$Method=="Lasso")
#Find mean for each
mean(sim1$Retention[sim1$Method=="Lasso"])
#Find mean for each
for (SNR in snr.vec){
print(mean(sim1$Retention[sim1$Method=="Lasso" & sim1$SNR == SNR]))
}
sim1$SNR == snr.vec[1]
mean(sim1$Retention [sim1$SNR == snr.vec[1]])
sim1 = sim1[1:40]
sim1 = sim1[1:40,]
mean(sim1$Retention [sim1$SNR == snr.vec[1]])
sim1$Retention [sim1$SNR == snr.vec[1]]
sim1$SNR
sim1$SNR == 0.05
print(mean(sim1$Retention[sim1$Method=="Lasso" & sim1$SNR == 0.5]))
for (SNR in snr.vec){
print(mean(sim1$Retention[sim1$Method=="Lasso" & sim1$SNR == 0.5]))
}
for (i in snr.vec){
print(mean(sim1$Retention[sim1$Method=="Lasso" & sim1$SNR == 0.5]))
}
sim1$Retention[sim1$Method=="Lasso" & sim1$SNR == 0.5]
sim1$Retention[sim1$Method=="Lasso"]# & sim1$SNR == 0.5]
sim1$Retention[(sim1$Method=="Lasso") & (sim1$SNR == 0.5)]
for (i in snr.vec){
print(mean(sim1$Retention[sim1$SNR == 0.5]))
}
sim1$Retention[sim1$SNR == 0.5]
sim1$Retention[sim1$SNR == 0.6]
sim1$SNR == 0.6
sim1$SNR == 6
sim1$Retention[sim1$SNR == 6]
sim1$SNR == 0.5
print(mean(sim1$Retention[sim1$SNR == 0.05]))
for (i in snr.vec){
print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == 0.05]))
}
for (i in snr.vec){
print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == i]))
}
snr.vec
for (i in snr.vec){
print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
}
for (i in snr.vec){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
sim1$SNR == i
}
for (i in snr.vec){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == i)
}
for (i in snr.vec){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == 0.05)
}
for (i in snr.vec){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == as.numeric(i))
}
#Find mean for each
for (i in snr.vec){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
#print(sim1$SNR == as.numeric(i))
print(i)
}
for (i in snr.vec){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
#print(sim1$SNR == as.numeric(i))
typeof(i)
}
for (i in snr.vec){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
#print(sim1$SNR == as.numeric(i))
print(typeof(i))
}
for (i in snr.vec){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
#print(sim1$SNR == as.numeric(i))
print(typeof(as.numeric(i)))
}
#Find mean for each
for (i in snr.vec){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
#print(sim1$SNR == as.numeric(i))
print(typeof(as.factor(i)))
}
sim1$SNR = rep(1:10, 4)
View(sim1)
for (i in 1:10){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == i)
}
for (i in 1:10){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == i)
print(typeof(i))
}
typeof(0.5)
sim1$SNR == 0.5
sim1$SNR == 0.05
sim1 <- read.csv("sim1.csv", header=TRUE)
sim1$SNR == 0.05
for (i in 0.05){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == i)
print(typeof(i))
}
for (i in (exp(seq(log(0.05), log(6), length=10)))){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == i)
print(typeof(i))
}
sim1 <- read.csv("sim1.csv", header=TRUE)
exp(seq(log(0.05), log(6), length=10))
snr.vec = exp(seq(log(0.05), log(6), length=10))
for (i in snr.vec){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == i)
print(typeof(i))
}
for (i in 0.05){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == i)
print(typeof(i))
}
for (i in snr.vec[1]){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == i)
print(typeof(i))
}
for (i in snr.vec[1]){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == as.numeric(i))
print(typeof(i))
}
for (i in snr.vec[1]){
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == as.integer(i))
print(typeof(i))
}
for (i in 1:10){
SNR = as.numeric(snr.vec[i])
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == SNR
print(typeof(SNR))
}
for (i in 1:10){
SNR = as.numeric(snr.vec[i])
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == SNR
print(typeof(SNR))
}
for (i in 1:10){
SNR = as.numeric(snr.vec[i])
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == SNR)
print(typeof(SNR))
}
for (i in 1:10){
SNR = as.numeric(snr.vec[i])
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == SNR)
print(SNR)
}
for (i in 1:10){
SNR = as.numeric(snr.vec[i])
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == SNR)
print(0.5)
}
for (i in 1:10){
SNR = as.numeric(snr.vec[i])
#print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == as.numeric(i)]))
print(sim1$SNR == 0.05)
print(0.05)
}
library(dplyr)
sim1 <- read.csv("sim1.csv", header=TRUE)
sim1 %>% group_by(SNR)
mean(sim1 %>% group_by(SNR))
sim1 %>% group_by(SNR)
%>%
summarise(continuos_mean = mean(continuous, na.rm = TRUE))
sim1 %>% group_by(SNR)
%>%
summarise(continuos_mean = mean(Retention, na.rm = TRUE))
sim1
sim1 %>% group_by(SNR)
%>%
summarise(continuos_mean = mean(sim1$Retention, na.rm = TRUE))
sim1 %>% group_by(SNR)
%>%
summarise(sim1)
%>% summarise(sim1)
sim1 %>% group_by(SNR)
%>% summarise(sim1)
sim1 %>% group_by(SNR) %>% summarise(sim1)
table(sim1)
summary(sim1)
grouped_sim <- group_by(sim1, ID_sim)
View(grouped_sim)
grouped_sim <- group_by(sim1, SNR)
View(grouped_sim)
df_grouped <- dplyr::group_by(sim1, SNR)
View(df_grouped)
df_grouped <- dplyr::group_by(sim1, SNR)
dplyr::summarise(df_grouped, mean(Retention), mean(Nonzero), mean(Prediction) )
sim1 = sim1[1:40,]
sim1 <- read.csv("sim1.csv", header=TRUE)
sim1 = sim1[1:40,]
df_grouped <- dplyr::group_by(sim1, SNR)
dplyr::summarise(df_grouped, mean(Retention), mean(Nonzero), mean(Prediction) )
library(ggplot2)
library(dplyr)
setwd("C:/Projects/Comp_Stat_Project")
sim1 <- read.csv("sim1.csv", header=TRUE)
sim1 = sim1[1:40,]
print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == 0.05]))
SNR = 0.05
print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == SNR]))
for (i in 0.05){
SNR = i
}
print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == SNR]))
snr.vec = exp(seq(log(0.05), log(6), length=10))
for (i in snr.vec){
SNR = i
}
print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == SNR]))
for (i in snr.vec){
SNR = i
print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == SNR]))
}
for (i in snr.vec){
SNR = i
print(sim1$SNR == SNR)
}
View(sim1)
for (i in snr.vec){
SNR = i
print(SNR)
print(sim1$SNR == SNR)
}
snr.vec == 0.05
snr.vec == 0.05000000
sim1 <- read.csv("sim1.csv", header=TRUE)
sim1 = sim1[1:40,]
sim1$SNR = round(sim1$SNR, digits=3)
snr.vec = round(exp(seq(log(0.05), log(6), length=10)), digits=3)
for (i in snr.vec){
SNR = i
print(mean(sim1$Retention[sim1$Method == "Lasso" & sim1$SNR == SNR]))
}
# https://debruine.github.io/posts/plot-comparison/
GeomSplitViolin <- ggproto(
"GeomSplitViolin",
GeomViolin,
draw_group = function(self, data, ..., draw_quantiles = NULL) {
data <- transform(data,
xminv = x - violinwidth * (x - xmin),
xmaxv = x + violinwidth * (xmax - x))
grp <- data[1,'group']
newdata <- dplyr::arrange(
transform(data, x = if(grp%%2==1) xminv else xmaxv),
if(grp%%2==1) y else -y
)
newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
newdata[c(1,nrow(newdata)-1,nrow(newdata)), 'x'] <- round(newdata[1, 'x'])
if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 1))
quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
aesthetics$alpha <- rep(1, nrow(quantiles))
both <- cbind(quantiles, aesthetics)
quantile_grob <- GeomPath$draw_panel(both, ...)
ggplot2:::ggname("geom_split_violin",
grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
} else {
ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
}
}
)
geom_split_violin <- function (mapping = NULL,
data = NULL,
stat = "ydensity",
position = "identity", ...,
draw_quantiles = NULL,
trim = TRUE,
scale = "area",
na.rm = FALSE,
show.legend = NA,
inherit.aes = TRUE) {
layer(data = data,
mapping = mapping,
stat = stat,
geom = GeomSplitViolin,
position = position,
show.legend = show.legend,
inherit.aes = inherit.aes,
params = list(trim = trim,
scale = scale,
draw_quantiles = draw_quantiles,
na.rm = na.rm, ...)
)
}
library(ggplot2)
library(dplyr)
library(cowplot)
library(ggplot2)
library(dplyr)
library(cowplot)
# https://debruine.github.io/posts/plot-comparison/
GeomSplitViolin <- ggproto(
"GeomSplitViolin",
GeomViolin,
draw_group = function(self, data, ..., draw_quantiles = NULL) {
data <- transform(data,
xminv = x - violinwidth * (x - xmin),
xmaxv = x + violinwidth * (xmax - x))
grp <- data[1,'group']
newdata <- dplyr::arrange(
transform(data, x = if(grp%%2==1) xminv else xmaxv),
if(grp%%2==1) y else -y
)
newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
newdata[c(1,nrow(newdata)-1,nrow(newdata)), 'x'] <- round(newdata[1, 'x'])
if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 1))
quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
aesthetics$alpha <- rep(1, nrow(quantiles))
both <- cbind(quantiles, aesthetics)
quantile_grob <- GeomPath$draw_panel(both, ...)
ggplot2:::ggname("geom_split_violin",
grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
} else {
ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
}
}
)
geom_split_violin <- function (mapping = NULL,
data = NULL,
stat = "ydensity",
position = "identity", ...,
draw_quantiles = NULL,
trim = TRUE,
scale = "area",
na.rm = FALSE,
show.legend = NA,
inherit.aes = TRUE) {
layer(data = data,
mapping = mapping,
stat = stat,
geom = GeomSplitViolin,
position = position,
show.legend = show.legend,
inherit.aes = inherit.aes,
params = list(trim = trim,
scale = scale,
draw_quantiles = draw_quantiles,
na.rm = na.rm, ...)
)
}
setwd("C:/Projects/Comp_Stat_Project")
sim1 <- read.csv("sim1.csv", header=TRUE)
true_sparsity = 5#sum(beta)
#Prepare the data
df <- sim1 %>% #create new data frame
na_if(Inf) %>% #Change INF values produced by RF
mutate(Retention = (Retention/true_sparsity)*100) %>%
group_by(SNR, Method) %>%
summarize(Mean_Ret = mean(Retention, na.rm=TRUE),
Mean_Zero = mean(Nonzero, na.rm=TRUE),
Mean_Pred = mean(Prediction, na.rm=TRUE),
SD_Ret = sd(Retention, na.rm= TRUE),
SD_Zero = sd(Nonzero, na.rm=TRUE),
SD_Pred = sd(Prediction, na.rm=TRUE))
View(df)
# Line breaks for SNR (logarithmic scale)
snr.breaks = round(exp(seq(from=min(log(sim1$SNR)),
to=max(log(sim1$SNR)),length=4)),2)
p1 <- ggplot(data=df, aes(x=SNR, y=Mean_Ret, color=Method)) +
geom_line(lwd=1) +
geom_point(pch=19) +
theme_bw() +
#facet_grid(rows = vars(Method)) +
#facet_grid(formula(paste(1,"~",2))) +
xlab("Signal-to-noise ratio") +
ylab("Retention Frequency") +
#geom_line(aes(x=SNR, y=5), lwd=0.5, linetype=3, color="black") +
#ggtitle("Simulation 1") +
geom_errorbar(aes(ymin=Mean_Ret-SD_Ret, ymax=Mean_Ret+SD_Ret), width=.2,
position=position_dodge(0.05)) +
scale_x_continuous(trans="log", breaks=snr.breaks)
p2 <- ggplot(data=df, aes(x=SNR, y=Mean_Zero, color=Method)) +
geom_line(lwd=1) +
geom_point(pch=19) +
theme_bw() +
#facet_grid(rows = vars(Method)) +
#facet_grid(formula(paste(1,"~",2))) +
xlab("Signal-to-noise ratio") +
ylab("Number of Nonzero Coeff") +
geom_line(aes(x=SNR, y=5), lwd=0.5, linetype=3, color="black") +
geom_errorbar(aes(ymin=Mean_Zero-SD_Zero, ymax=Mean_Zero+SD_Zero), width=.2,
position=position_dodge(0.05)) +
scale_x_continuous(trans="log", breaks=snr.breaks)
p3 <- ggplot(data=df, aes(x=SNR, y=Mean_Pred, color=Method)) +
geom_line(lwd=1) +
geom_point(pch=19) +
theme_bw() +
#facet_grid(rows = vars(Method)) +
#facet_grid(formula(paste(1,"~",2))) +
xlab("Signal-to-noise ratio") +
ylab("Mean-squared Prediction Error") +
geom_errorbar(aes(ymin=Mean_Pred-SD_Pred, ymax=Mean_Pred+SD_Pred), width=.2,
position=position_dodge(0.05)) +
scale_x_continuous(trans="log", breaks=snr.breaks)
violin_data = sim1[sim1$SNR==sim1$SNR[600] | sim1$SNR==sim1$SNR[2000],]
violin_data$SNR = as.factor(round(violin_data$SNR, digits=2))
#boxplot
p4 <- ggplot(data=violin_data, aes(x=Method, y=Nonzero, fill=SNR)) +
geom_split_violin(color="white", trim=FALSE) +
scale_fill_brewer(palette="Dark2") +
theme_bw() +
theme(legend.position=c(0.9,.75))
# get legend manually
legend <- get_legend(
# create some space to the left of the legend
p1 + theme(legend.box.margin = margin(0, 0, 0, 12))
)
# add the legend to the row we made earlier. Give it one-third of
# the width of one plot (via rel_widths).
g1 <- plot_grid(p1 +   theme(legend.position="none"),
p2 +   theme(legend.position="none"),
p3 +   theme(legend.position="none"),
p4,
ncol=2,
nrow=2)
# now add the title
title <- ggdraw() +
draw_label(
"Simulation 1: n=100, p=50, Beta-type = 1, s=5, rho = 0.5",
fontface = 'bold',
x = 0,
hjust = 0
) +
theme(
# add margin on the left of the drawing canvas,
# so title is aligned with left edge of first plot
plot.margin = margin(0, 0, 0, 7)
)
g2 <- plot_grid(
title, g1,
ncol = 1,
# rel_heights values control vertical title margins
rel_heights = c(0.1, 1)
)
# get legend manually
legend <- get_legend(
# create some space to the left of the legend
p1 + theme(legend.box.margin = margin(0, 0, 0, 12))
)
plot_grid(g2, legend, rel_widths = c(3, .6))
